# 处理代码混淆

## 加密分析流程总结

- 1, 查看关键包 - 分析哪些参数是加密的
- 2, 搜索参数
  - 参数名= / 参数名 = / 参数名: / 参数名: 参数名
    - 2.1 查看网络面板的Initiator(发起)
    - 2.2 xhr断电调试
    - 2.3 hook相关逻辑
- 3, 分析加密
- 4, 补全加密逻辑

## 样例一总结

将 JavaScript 代码转换成颜文字网络表情的编码以达到混淆的目的

原理: 这类混淆通常都是使用构造函数将字符串作为代码运行

例如:

```js
const sum = new Function('a', 'b', 'return a + b')
console.log(sum(s, 6));
```

解决方法:

- 1, 直接将混淆后的代码粘贴到控制台通过VM查看源代码
- 2, 删除代码结尾的 ('_'); 替换为 toString() 或将修改后的代码粘贴到控制台运行

### 样例原理

这类混淆的原理都是通过(0)["constructor"]["constructor"](code)()来执行代码的, 上面这一串代码等价于 Function(code)()

Function 构造函数创建了一个新的Function对象, 我们直接调用构造函数就可以动态创建函数了.

就像下面这段代码

```js
const sum = new Function('a', 'b', 'return a + b')
console.log(sum(2, 6));
```

传递给Function的所有参数按照传递顺序被视为函数的形参, 最后一个函数传入函数体, 调用执行的时候回创建一个计算两位数之和的函数了.

## 样例二总结

将 JavaScript 代码转换仅由符号组成的代码以达到混淆的目的原理: 这类混淆通常都是使用构造函数将字符串作为代码运行转换流程大致如下:

```js
Function("alert(1)")()
(0)["constructor"]["constructor"]("alert(1)")();
$ = "constructor";
$$ = "alert(1)";
$_ = ~[];
($_)[$][$]($$)();
```

解决方法:

- 1, 直接将混淆后的代码粘贴至控制台通过VM查看源代码
- 2, 删除代码结尾的 () 替换为 toString() 或将修改后的代码粘贴到控制台运行.

## 样例三总结

将 JavaScript 代码转换成只有6种字符 (\[, \], \(, \), !, +) 的编码, 以达到混淆的目的

例如:

- '0': '[+[]]'
- '1': '[+!+[]]'
- '2': '[!+[]+!+[]]'
- 'a': '[false+""](1)'
- 'b': '(Function("return{}")()+"")[2]'
- 'c': '[[]["filter"]+""](3)'

解决方案:

- 1, 直接将混淆后的代码粘贴至控制台通过VM查看源代码
- 2, 删除代码结果的 () 替换为 toString() 或 将修改的代码粘贴至控制台运行
- 3, 将代码结尾最后一对的 () 包含的代码抽离出来单独运行

